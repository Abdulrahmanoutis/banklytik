{
  "functions": {
    "fix_missing_space_date": {
      "description": "Fix OCR and spacing issues in date strings before parsing.",
      "source": "def fix_missing_space_date(date_str):\n    \"\"\"\n    Fix OCR spacing and colon issues in date strings.\n    This helps DeepSeek pattern parsing and fallback regex cleaning.\n    \"\"\"\n    if not isinstance(date_str, str):\n        return date_str\n\n    s = date_str.strip()\n\n    # Fix common missing spaces between day/time\n    s = re.sub(r\"(\\d{2})(?=\\d{2}:\\d{2})\", r\"\\1 \", s)\n    s = re.sub(r\"(\\d{4})(?=[A-Za-z]{3,})\", r\"\\1 \", s)\n    s = re.sub(r\"(\\d{2}:\\d{2})(?=\\d{2})\", r\"\\1 \", s)\n    s = re.sub(r\"\\s{2,}\", \" \", s)\n\n    return s.strip()\n"
    },
    "parse_date_str": {
      "description": "Robust multi-strategy date parser for bank statements.",
      "source": "def parse_date_str(s_raw):\n    \"\"\"\n    Parse a wide range of bank-statement date formats safely.\n    Handles:\n      - Kuda format: 'DD/MM/YY HH:MM:SS' or 'DD/MM/YY'\n      - OPay format: 'YYYY MMM DD HH:MM:SS' or 'DD MMM YYYY'\n      - DD/MM/YYYY etc.\n    Returns a naive datetime (caller may localize) or None.\n    \"\"\"\n    if s_raw is None:\n        return None\n\n    s = str(s_raw).strip()\n    print(f\"\ud83d\udd0d DEBUG parse_date_str: Input = '{s}' (type: {type(s).__name__})\")\n    \n    if s == \"\" or s.lower() in (\"nan\", \"none\", \"nat\"):\n        print(f\"   \u2192 Empty/null value, returning None\")\n        return None\n\n    # Normalize separators\n    s_norm = re.sub(r\"[-\\.]\", \"/\", s)\n\n    # 1) OPay Trans. Time format: YYYY MMM DD HH:MM:SS (e.g., \"2025 Feb 24 07:36:01\")\n    opay_dt_pattern = r'^\\s*(\\d{4})\\s+([A-Za-z]{3})\\s+(\\d{1,2})\\s+(\\d{1,2}):(\\d{2}):(\\d{2})\\s*$'\n    m = re.match(opay_dt_pattern, s)\n    if m:\n        try:\n            year, month_str, day, hour, minute, second = m.groups()\n            month = datetime.strptime(month_str, \"%b\").month\n            dt = datetime(int(year), int(month), int(day), int(hour), int(minute), int(second))\n            print(f\"\u2705 Parsed OPay datetime: {s} \u2192 {dt}\")\n            return dt\n        except Exception as e:\n            print(f\"\u26a0\ufe0f OPay datetime parsing failed for '{s}': {e}\")\n\n    # 2) OPay Value Date format: DD MMM YYYY (e.g., \"23 Feb 2025\")\n    opay_date_pattern = r'^\\s*(\\d{1,2})\\s+([A-Za-z]{3})\\s+(\\d{4})\\s*$'\n    m = re.match(opay_date_pattern, s)\n    if m:\n        try:\n            day, month_str, year = m.groups()\n            month = datetime.strptime(month_str, \"%b\").month\n            dt = datetime(int(year), int(month), int(day))\n            print(f\"\u2705 Parsed OPay date: {s} \u2192 {dt}\")\n            return dt\n        except Exception as e:\n            print(f\"\u26a0\ufe0f OPay date parsing failed for '{s}': {e}\")\n\n    # 3) Kuda style full datetime: DD/MM/YY HH:MM:SS (or single-digit day/month)\n    kuda_dt_pattern = r'^\\s*(\\d{1,2})/(\\d{1,2})/(\\d{2})\\s+(\\d{1,2}):(\\d{2}):(\\d{2})\\s*$'\n    m = re.match(kuda_dt_pattern, s_norm)\n    if m:\n        try:\n            day, month, year2, hour, minute, second = m.groups()\n            year = int(year2)\n            # convert 2-digit year to 4-digit (assume 2000-2099)\n            year_full = 2000 + year if year < 100 else year\n            dt = datetime(int(year_full), int(month), int(day), int(hour), int(minute), int(second))\n            print(f\"\u2705 Parsed Kuda datetime: {s} \u2192 {dt}\")\n            return dt\n        except Exception as e:\n            print(f\"\u26a0\ufe0f Kuda datetime parsing failed for '{s}': {e}\")\n\n    # 4) Kuda date only: DD/MM/YY or DD/MM/YYYY\n    kuda_date_pattern = r'^\\s*(\\d{1,2})/(\\d{1,2})/(\\d{2,4})\\s*$'\n    m2 = re.match(kuda_date_pattern, s_norm)\n    if m2:\n        try:\n            day, month, year_token = m2.groups()\n            year = int(year_token)\n            if year < 100:\n                year = 2000 + year\n            dt = datetime(year, int(month), int(day))\n            print(f\"\u2705 Parsed Kuda date: {s} \u2192 {dt}\")\n            return dt\n        except Exception as e:\n            print(f\"\u26a0\ufe0f Kuda date parsing failed for '{s}': {e}\")\n\n    # 5) If it's a time-only string (e.g., '23:08:23'), try to attach today's date as fallback\n    time_only = re.match(r'^\\s*(\\d{1,2}):(\\d{2}):(\\d{2})\\s*$', s)\n    if time_only:\n        try:\n            h, m_, s_ = time_only.groups()\n            now = datetime.utcnow()\n            dt = datetime(now.year, now.month, now.day, int(h), int(m_), int(s_))\n            print(f\"\u2705 Parsed time-only string: {s} \u2192 {dt} (attached today)\")\n            return dt\n        except Exception:\n            pass\n\n    # 6) Pandas fallback with dayfirst (but NOT for YYYY-MM-DD format)\n    try:\n        # Check for month-year only patterns (e.g., \"Feb 2025\") - these are incomplete dates\n        month_year_pattern = r'^([A-Za-z]{3,})\\s+(\\d{4})$'\n        if re.match(month_year_pattern, s):\n            print(f\"\u26a0\ufe0f Incomplete date pattern detected: '{s}' - missing day component\")\n            return None  # Let the validation system handle this\n        \n        # Don't use dayfirst=True if it's already in YYYY-MM-DD format\n        use_dayfirst = not bool(re.match(r'^\\d{4}-\\d{2}-\\d{2}', s))\n        parsed_pd = pd.to_datetime(s, errors=\"coerce\", dayfirst=use_dayfirst)\n        if pd.notna(parsed_pd):\n            dt = parsed_pd.to_pydatetime()\n            print(f\"\u2705 Pandas parsed: {s} \u2192 {dt} (dayfirst={use_dayfirst})\")\n            return dt\n    except Exception as e:\n        print(f\"\u26a0\ufe0f Pandas parse attempt failed for '{s}': {e}\")\n\n    # 7) Manual format list fallback\n    known_formats = [\n        \"%d/%m/%Y %H:%M:%S\",\n        \"%d/%m/%y %H:%M:%S\",\n        \"%d/%m/%Y %H:%M\",\n        \"%d/%m/%y %H:%M\",\n        \"%d/%m/%Y\",\n        \"%d/%m/%y\",\n        \"%Y-%m-%d %H:%M:%S\",\n        \"%Y-%m-%d\",\n        \"%b %d, %Y\",\n        \"%d %b %Y\",\n        \"%d %b %Y %H:%M:%S\",  # Additional format for OPay-style\n    ]\n    for fmt in known_formats:\n        try:\n            dt = datetime.strptime(s, fmt)\n            print(f\"\u2705 Manual format parsed: {s} \u2192 {dt} using {fmt}\")\n            return dt\n        except Exception:\n            continue\n\n    print(f\"\u274c All date parsing methods failed for: '{s}'\")\n    return None\n"
    },
    "robust_clean_dataframe": {
      "description": "Top-level cleaning pipeline for statement DataFrames.",
      "source": "def robust_clean_dataframe(df_raw):\n    \"\"\"\n    Clean and normalize extracted bank statement tables.\n    Handles both:\n    1. Old format from direct_processor (Trans. Time, Description, etc.)\n    2. New format from column_mapper (date, description, debit, credit, etc.)\n    \n    Filters junk rows and ensures consistent canonical format.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    print(\"DEBUG: robust_clean_dataframe input shape:\", getattr(df_raw, \"shape\", None))\n    df = df_raw.copy() if df_raw is not None else pd.DataFrame()\n\n    if df is None or df.empty:\n        cols = [\n            \"date\", \"raw_date\", \"value_date\", \"description\",\n            \"debit\", \"credit\", \"balance\", \"channel\",\n            \"transaction_reference\", \"row_issue\",\n        ]\n        return pd.DataFrame(columns=cols)\n\n    # PRESERVE raw date BEFORE any normalization (important for validation)\n    if 'date' in df.columns:\n        df['_original_date'] = df['date'].astype(str)\n    \n    # Normalize text (but NOT raw date values which we need for validation)\n    df = df.map(lambda v: normalize_text(v) if pd.notna(v) else \"\")\n    \n    print(f\"DEBUG: Incoming columns: {list(df.columns)}\")\n    print(f\"DEBUG: Data types: {df.dtypes.to_dict()}\")\n    print(f\"DEBUG: First row sample:\\n{df.head(1).to_string()}\")\n\n    # Detect if this is the NEW format from column_mapper\n    has_standardized_cols = all(col in df.columns for col in ['date', 'description', 'debit', 'credit'])\n    print(f\"DEBUG: Checking for standardized cols: date={('date' in df.columns)}, description={('description' in df.columns)}, debit={('debit' in df.columns)}, credit={('credit' in df.columns)}\")\n    \n    if has_standardized_cols:\n        print(\"\u2705 Detected standardized format from column_mapper\")\n        # Already in standardized format - just ensure all required columns exist\n        \n        # PRESERVE raw_date BEFORE any parsing (for validation) - use original before normalization\n        if '_original_date' in df.columns:\n            df['raw_date'] = df['_original_date']\n        elif 'raw_date' not in df.columns:\n            df['raw_date'] = df['date'].astype(str) if 'date' in df.columns else \"\"\n        else:\n            # Make sure raw_date is preserved as-is before parsing\n            df['raw_date'] = df['raw_date'].astype(str)\n        \n        # Clean up temporary column\n        df = df.drop(columns=['_original_date'], errors='ignore')\n            \n        if 'value_date' not in df.columns:\n            df['value_date'] = None\n        if 'channel' not in df.columns:\n            df['channel'] = df['description'].apply(extract_channel) if 'description' in df.columns else \"OTHER\"\n        if 'transaction_reference' not in df.columns:\n            df['transaction_reference'] = \"\"\n        \n        # Parse dates if they're strings\n        if df['date'].dtype == 'object':\n            df['date'] = df['date'].apply(lambda v: parse_date_str(v) if isinstance(v, str) and v.strip() else v)\n        \n        # Handle OPay format: single \"amount\" column with +/- values\n        # If debit/credit are empty but amount column exists, split it\n        if 'amount' in df.columns:\n            print(\"\ud83d\udd0d Detected 'amount' column - checking if we need to split it to debit/credit\")\n            \n            # Check if debit and credit are mostly empty\n            debit_empty = ('debit' not in df.columns) or (df['debit'].astype(str).str.strip() == '').all()\n            credit_empty = ('credit' not in df.columns) or (df['credit'].astype(str).str.strip() == '').all()\n            \n            if debit_empty and credit_empty:\n                print(\"\u2705 Splitting 'amount' column into debit/credit based on sign\")\n                # Convert amount to float first\n                df['_amount_float'] = df['amount'].apply(clean_amount)\n                # Split into debit (negative) and credit (positive)\n                df['debit'] = df['_amount_float'].apply(lambda x: abs(x) if x < 0 else 0.0)\n                df['credit'] = df['_amount_float'].apply(lambda x: abs(x) if x > 0 else 0.0)\n                df = df.drop(columns=['_amount_float'])\n        \n        # Convert amounts to float\n        for col in ['debit', 'credit', 'balance']:\n            if col in df.columns:\n                if df[col].dtype == 'object':\n                    df[col] = df[col].apply(clean_amount)\n                else:\n                    df[col] = df[col].fillna(0.0).astype(float)\n            else:\n                # Create empty column if it doesn't exist\n                df[col] = 0.0\n        \n    else:\n        print(\"\u26a0\ufe0f Detected old format - remapping columns\")\n        # OLD FORMAT: Assign fallback headers if needed\n        if not any(\"date\" in str(c).lower() for c in df.columns):\n            df.columns = [\n                \"Trans. Time\", \"Value Date\", \"Description\",\n                \"Debit/Credit(W)\", \"Balance(N)\", \"Channel\", \"Transaction Reference\"\n            ][: len(df.columns)]\n\n        # Fill required columns for old format\n        required = {\n            \"Trans. Time\": \"\",\n            \"Value Date\": \"\",\n            \"Description\": \"\",\n            \"Debit/Credit(W)\": \"\",\n            \"Balance(N)\": \"0\",\n            \"Channel\": \"\",\n            \"Transaction Reference\": \"\",\n        }\n        for c, default in required.items():\n            if c not in df.columns:\n                df[c] = default\n\n        # Parse and clean for old format\n        df[\"raw_date\"] = df[\"Trans. Time\"].astype(str)\n        df[\"date\"] = df[\"raw_date\"].apply(lambda v: parse_date_str(v) if str(v).strip() else None)\n        df[\"value_date\"] = df[\"Value Date\"].apply(lambda v: parse_date_str(v) if str(v).strip() else None)\n        df[\"description\"] = df[\"Description\"].astype(str)\n        df[\"balance\"] = df[\"Balance(N)\"].apply(clean_amount)\n\n        dc = df[\"Debit/Credit(W)\"].astype(str)\n        df[\"debit\"] = dc.apply(lambda x: clean_amount(x) if \"-\" in x else 0.0)\n        df[\"credit\"] = dc.apply(lambda x: clean_amount(x) if \"+\" in x else 0.0)\n        df[\"channel\"] = df[\"Channel\"].apply(extract_channel)\n        df[\"transaction_reference\"] = df[\"Transaction Reference\"].astype(str)\n\n    # --- Filter rows: keep if has valid date OR has transaction amount ---\n    before = len(df)\n    \n    # More lenient filtering: accept rows with valid dates OR non-zero amounts OR valid balance\n    df['_has_date'] = df[\"date\"].notna()\n    df['_has_debit'] = df[\"debit\"].astype(float) != 0\n    df['_has_credit'] = df[\"credit\"].astype(float) != 0\n    df['_has_balance'] = df[\"balance\"].astype(float) != 0\n    df['_has_desc'] = df[\"description\"].astype(str).str.strip() != \"\"\n    \n    # Keep rows that have: (date AND description) OR (transaction amounts) OR (balance)\n    df = df[\n        (df['_has_date'] & df['_has_desc']) |  # Valid date + description\n        (df['_has_debit'] | df['_has_credit']) |  # Transaction amounts\n        df['_has_balance']  # Valid balance\n    ]\n    \n    # Remove temporary columns\n    df = df.drop(columns=['_has_date', '_has_debit', '_has_credit', '_has_balance', '_has_desc'], errors='ignore')\n    \n    after = len(df)\n    print(f\"\ud83e\uddf9 Filtered junk rows: {before - after} removed, {after} kept\")\n\n    # Detect row issues\n    def _detect_issues(r):\n        issues = []\n        \n        # Check for invalid/missing date\n        if r[\"date\"] is None:\n            issues.append(\"\u274c INVALID_DATE\")\n        else:\n            # Check if date appears incomplete (defaulted to midnight with no time component)\n            # This typically happens when only date (no time) is provided\n            parsed_date = r[\"date\"]\n            if isinstance(parsed_date, datetime):\n                # If time is 00:00:00 and raw_date doesn't contain time indicators\n                if parsed_date.hour == 0 and parsed_date.minute == 0 and parsed_date.second == 0:\n                    raw = str(r.get(\"raw_date\", \"\")).strip()\n                    # Check if raw_date has any time indicators\n                    if not re.search(r'\\d{1,2}:\\d{2}', raw) and raw:\n                        issues.append(\"\u26a0\ufe0f INCOMPLETE_DATE\")\n        \n        if r.get(\"value_date\") is None and str(r.get(\"raw_date\", \"\")).strip():\n            issues.append(\"\u26a0\ufe0f MISSING_VALUE_DATE\")\n        if r.get(\"channel\") == \"EMPTY\":\n            issues.append(\"\u26a0\ufe0f MISSING_CHANNEL\")\n        \n        # Check for zero transaction amounts with valid description\n        debit_val = float(r.get(\"debit\", 0) or 0)\n        credit_val = float(r.get(\"credit\", 0) or 0)\n        desc = str(r.get(\"description\", \"\")).strip()\n        if debit_val == 0 and credit_val == 0 and desc and r[\"date\"] is not None:\n            issues.append(\"\u26a0\ufe0f ZERO_AMOUNT\")\n        \n        return \" | \".join(issues) if issues else \"\"\n\n    df[\"row_issue\"] = df.apply(_detect_issues, axis=1)\n\n    # Canonical order\n    cols = [\n        \"date\", \"raw_date\", \"value_date\", \"description\",\n        \"debit\", \"credit\", \"balance\", \"channel\",\n        \"transaction_reference\", \"row_issue\",\n    ]\n    for c in cols:\n        if c not in df.columns:\n            df[c] = pd.NA\n\n    final_df = df[cols]\n\n    # Apply date validation using the new DateValidator\n    print(\"\\n\ud83d\udd0d Applying OCR error detection and date validation...\")\n    final_df = validate_and_flag_dates(final_df, verbose=True)\n\n    # Save debug snapshot\n    try:\n        DEBUG_DIR = os.path.join(getattr(settings, \"BASE_DIR\", \".\"), \"debug_exports\")\n        os.makedirs(DEBUG_DIR, exist_ok=True)\n        stamp = int(datetime.utcnow().timestamp())\n        path = os.path.join(DEBUG_DIR, f\"robust_clean_snapshot_{stamp}.csv\")\n        final_df.to_csv(path, index=False)\n        print(f\"\ud83d\udcbe Saved cleaned snapshot \u2192 {path}\")\n    except Exception as e:\n        print(f\"\u26a0\ufe0f Snapshot save failed: {e}\")\n\n    return final_df\n"
    }
  },
  "rules": {
    "dates": [],
    "amounts": [],
    "text_normalization": []
  },
  "examples": {
    "dates": [],
    "amounts": [],
    "text_normalization": []
  }
}