{
  "functions": {
    "fix_missing_space_date": {
      "description": "Fix OCR and spacing issues in date strings before parsing.",
      "source": "def fix_missing_space_date(date_str):\n    \"\"\"\n    Fix OCR spacing and colon issues in date strings.\n    Dynamically applies regex rules loaded from knowledge base (dates_rules.md)\n    and falls back to internal known patterns if needed.\n    \"\"\"\n    if not isinstance(date_str, str):\n        return date_str\n\n    # --- Step 1: Load rules from knowledge base ---\n    kb_rules = get_rules(\"dates\") or []\n    changed_any = False\n\n    # Apply dynamic rules (from knowledge base)\n    for rule_text in kb_rules:\n        pattern_match = re.search(r\"Regex:\\s*(.+)\", rule_text)\n        replace_match = re.search(r\"Replace:\\s*(.+)\", rule_text)\n\n        if pattern_match and replace_match:\n            pattern = pattern_match.group(1).strip()\n            replacement = replace_match.group(1).strip()\n\n            try:\n                new_str = re.sub(pattern, replacement, date_str)\n                if new_str != date_str:\n                    print(f\"DEBUG: Applied KB rule â†’ '{pattern}'\")\n                    print(f\"       '{date_str}' -> '{new_str}'\")\n                    date_str = new_str\n                    changed_any = True\n            except re.error as e:\n                print(f\"âš ï¸ Regex error in KB rule '{pattern}': {e}\")\n\n    # --- Step 2: Apply fallback internal patterns ---\n    internal_patterns = [\n        # Pattern 1: Missing space between day and time (with seconds)\n        (r'(\\d{4}\\s+[A-Za-z]{3,}\\s+)(\\d{2})(\\d{2}:\\d{2}\\s+\\d{2})', r'\\1\\2 \\3', \"pattern1\"),\n        # Pattern 2: Missing space between day and time (no seconds)\n        (r'(\\d{4}\\s+[A-Za-z]{3,}\\s+)(\\d{2})(\\d{2}:\\d{2})', r'\\1\\2 \\3', \"pattern2\"),\n        # Pattern 3: \"23Feb2025 10:00\" â†’ \"23 Feb 2025 10:00\"\n        (r'(\\d{2})([A-Za-z]{3,})(\\d{4}\\s+\\d{2}:\\d{2})', r'\\1 \\2 \\3', \"pattern3\"),\n        # Pattern 4: Generic fallback \"2310:00\" â†’ \"23 10:00\"\n        (r'(\\d{2})(\\d{2}:\\d{2})', r'\\1 \\2', \"pattern4\"),\n        # Pattern 5: Colon-space issue \"20:11: 58\" â†’ \"20:11 58\"\n        (r'(\\d{2}:\\d{2}):\\s+(\\d{2})', r'\\1 \\2', \"pattern5\"),\n    ]\n\n    for pattern, replacement, label in internal_patterns:\n        try:\n            new_str = re.sub(pattern, replacement, date_str)\n            if new_str != date_str:\n                print(f\"DEBUG: Fixed {label}: '{date_str}' -> '{new_str}'\")\n                date_str = new_str\n                changed_any = True\n        except re.error as e:\n            print(f\"âš ï¸ Regex error in internal rule {label}: {e}\")\n\n    # --- Step 3: Final confirmation log ---\n    if changed_any:\n        print(f\"DEBUG: Final fixed date string: '{date_str}'\")\n\n    return date_str\n"
    },
    "parse_date_str": {
      "description": "Robust multi-strategy date parser for bank statements.",
      "source": "def parse_date_str(date_str):\n    \"\"\"\n    Parse bank statement dates with robust fallback mechanisms.\n    Handles OCR errors like missing spaces between day and time.\n    \"\"\"\n    if pd.isna(date_str):\n        return None\n\n    s = str(date_str).strip()\n    if s.lower() in [\"\", \"nan\", \"none\", \"null\", \"0.0\"]:\n        return None\n\n    print(f\"DEBUG: Attempting to parse date: '{s}'\")\n\n    # ðŸ§© Step 1: Normalize OCR spacing before parsing\n    corrected = fix_missing_space_date(s)\n    if corrected != s:\n        print(f\"DEBUG: Applied fix_missing_space_date: '{s}' -> '{corrected}'\")\n        s = corrected\n\n    # ðŸ§© Step 2: Try dateparser first\n    try:\n        parsed = dateparser.parse(\n            s,\n            settings={\n                \"DATE_ORDER\": \"DMY\",\n                \"PREFER_DAY_OF_MONTH\": \"first\",\n                \"PREFER_DATES_FROM\": \"current_period\",\n                \"RETURN_AS_TIMEZONE_AWARE\": False,\n            },\n        )\n        if parsed:\n            print(f\"DEBUG: dateparser successfully parsed '{s}' -> {parsed}\")\n            return parsed\n    except Exception as e:\n        print(f\"DEBUG: dateparser failed for '{s}': {e}\")\n\n    # ðŸ§© Step 3: Manual fallback formats\n    s_clean = re.sub(r\"[.,-]\", \" \", s)\n    s_clean = re.sub(r\"\\s+\", \" \", s_clean).strip()\n    for fmt in [\n        \"%Y %b %d %H:%M %S\",\n        \"%Y %b %d %H:%M:%S\",\n        \"%Y %b %d %H:%M\",\n        \"%d %b %Y %H:%M %S\",\n        \"%d %b %Y %H:%M:%S\",\n        \"%d %b %Y %H:%M\",\n        \"%Y %b %d\",\n        \"%d %b %Y\",\n        \"%b %Y\",\n        \"%d/%m/%Y\",\n        \"%d-%m-%Y\",\n        \"%m/%d/%Y\",\n    ]:\n        try:\n            parsed = datetime.strptime(s_clean, fmt)\n            if fmt == \"%b %Y\":\n                parsed = parsed.replace(day=1)\n            print(f\"DEBUG: strptime successfully parsed '{s}' -> {parsed} using '{fmt}'\")\n            return parsed\n        except ValueError:\n            continue\n\n    # ðŸ§© Step 4: Pandas fallback\n    try:\n        parsed = pd.to_datetime(s_clean, errors=\"coerce\", dayfirst=True)\n        if not pd.isna(parsed):\n            print(f\"DEBUG: pandas successfully parsed '{s}' -> {parsed}\")\n            return parsed.to_pydatetime()\n    except Exception as e:\n        print(f\"DEBUG: pandas failed for '{s}': {e}\")\n\n    print(f\"DEBUG: All parsing methods failed for: '{s}'\")\n    return None\n"
    },
    "robust_clean_dataframe": {
      "description": "Top-level cleaning pipeline for statement DataFrames.",
      "source": "def robust_clean_dataframe(df_raw):\n    \"\"\"\n    Clean extracted statement tables safely and robustly.\n    Handles OCR noise, malformed dates, and numeric issues.\n    \"\"\"\n    print(\"DEBUG: robust_clean_dataframe input shape:\", df_raw.shape)\n\n    df = df_raw.copy()\n    df = df.applymap(lambda v: normalize_text(v) if pd.notna(v) else \"\")\n\n    headers = [\n        \"Trans. Time\", \"Value Date\", \"Description\",\n        \"Debit/Credit(W)\", \"Balance(N)\", \"Channel\", \"Transaction Reference\"\n    ]\n    df.columns = headers[:len(df.columns)]\n\n    print(\"DEBUG: First 5 date strings in 'Trans. Time':\")\n    for i, date_str in enumerate(df[\"Trans. Time\"].head(5)):\n        print(f\"  {i}: '{date_str}'\")\n\n    df[\"raw_date\"] = df[\"Trans. Time\"]\n    df[\"date\"] = df[\"Trans. Time\"].apply(parse_date_str)\n    df[\"value_date\"] = df[\"Value Date\"].apply(parse_date_str)\n    df[\"description\"] = df[\"Description\"]\n    df[\"balance\"] = df[\"Balance(N)\"].apply(clean_amount)\n\n    dc = df[\"Debit/Credit(W)\"].astype(str)\n    df[\"debit\"] = dc.apply(lambda x: clean_amount(x) if \"-\" in x else 0.0)\n    df[\"credit\"] = dc.apply(lambda x: clean_amount(x) if \"+\" in x else 0.0)\n\n    df[\"channel\"] = df[\"Channel\"].apply(extract_channel)\n    df[\"transaction_reference\"] = df[\"Transaction Reference\"]\n\n    def detect_issues(row):\n        issues = []\n        if row[\"date\"] is None:\n            issues.append(\"invalid_date\")\n        if row[\"value_date\"] is None:\n            issues.append(\"invalid_value_date\")\n        if isinstance(row[\"balance\"], str) and \"INVALID_AMOUNT\" in row[\"balance\"]:\n            issues.append(\"invalid_balance\")\n        if row[\"channel\"] == \"EMPTY\":\n            issues.append(\"missing_channel\")\n        return \", \".join(issues) if issues else \"\"\n\n    df[\"row_issue\"] = df.apply(detect_issues, axis=1)\n\n    print(\"DEBUG: Cleaned shape:\", df.shape)\n    print(\"DEBUG: Date parsing summary:\")\n    print(f\"  - Valid dates: {df['date'].notna().sum()}\")\n    print(f\"  - Invalid dates: {df['date'].isna().sum()}\")\n\n    return df[\n        [\"date\", \"raw_date\", \"value_date\", \"description\", \"debit\", \"credit\",\n         \"balance\", \"channel\", \"transaction_reference\", \"row_issue\"]\n    ]\n"
    }
  },
  "rules": {
    "dates": [],
    "amounts": [],
    "text_normalization": []
  },
  "examples": {
    "dates": [],
    "amounts": [],
    "text_normalization": []
  },
  "regex_rules": [
    "Regex: (\\d{4}\\s+[A-Za-z]{3,}\\s+)(\\d{2})(\\d{2}:\\d{2})  Replace: \\1\\2 \\3  Notes: Fixes missing space between day and time.",
    "Regex: (\\d{2}:\\d{2}):\\s+(\\d{2})  Replace: \\1 \\2  Notes: Fixes colon-space issue like '20:11: 58'."
  ]
}